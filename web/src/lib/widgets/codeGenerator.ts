/**
 * Widget Code Generator
 *
 * Generates Übersicht widget code (.jsx) for cards, stats, and templates.
 */

import { WIDGET_CARDS, WIDGET_STATS, WIDGET_TEMPLATES } from './widgetRegistry'
import { generateWidgetStyles } from './styleConverter'

export interface WidgetConfig {
  type: 'card' | 'stat' | 'template'
  cardType?: string
  statIds?: string[]
  templateId?: string
  apiEndpoint: string
  refreshInterval: number
  theme: 'dark' | 'light'
}

// Generate Übersicht widget code for a single card
export function generateCardWidget(
  cardType: string,
  apiEndpoint: string,
  refreshInterval: number = 30000
): string {
  const card = WIDGET_CARDS[cardType]
  if (!card) {
    throw new Error(`Unknown card type: ${cardType}`)
  }

  const endpoints = card.apiEndpoints.map((ep) => `${apiEndpoint}${ep}`)

  return `/**
 * ${card.displayName} Widget
 * ${card.description}
 *
 * Generated by KubeStellar Console
 * Install: Move to ~/Library/Application Support/Übersicht/widgets/
 * Config: Set KC_API_TOKEN environment variable
 */

// Configuration
const config = {
  apiEndpoint: '${apiEndpoint}',
  refreshInterval: ${refreshInterval},
};

// Fetch data from KC API
export const command = (dispatch) => {
  fetch('${endpoints[0]}')
    .then(response => {
      if (!response.ok) throw new Error(\`HTTP \${response.status}\`);
      return response.json();
    })
    .then(data => dispatch({ type: 'DATA_LOADED', data }))
    .catch(error => dispatch({ type: 'ERROR', error: error.message }));
};

export const refreshFrequency = config.refreshInterval;

export const initialState = {
  loading: true,
  error: null,
  data: null,
};

export const updateState = (event, previousState) => {
  switch (event.type) {
    case 'DATA_LOADED':
      return { ...previousState, loading: false, error: null, data: event.data };
    case 'ERROR':
      return { ...previousState, loading: false, error: event.error };
    default:
      return previousState;
  }
};

${generateWidgetStyles()}

${generateCardRenderFunction(cardType)}
`
}

// Generate render function for specific card type
function generateCardRenderFunction(cardType: string): string {
  const card = WIDGET_CARDS[cardType]

  switch (cardType) {
    case 'cluster_health':
      return `
export const render = ({ state }) => {
  if (state.loading) {
    return <div style={styles.card}><span style={{color: styles.colors.info}}>Loading...</span></div>;
  }
  if (state.error) {
    return <div style={styles.card}><span style={{color: styles.colors.error}}>Error: {state.error}</span></div>;
  }

  const clusters = state.data?.clusters || [];
  const healthy = clusters.filter(c => c.healthy !== false).length;
  const unhealthy = clusters.length - healthy;

  return (
    <div style={styles.card}>
      <div style={styles.cardTitle}>
        <span style={{...styles.statusDot, backgroundColor: unhealthy > 0 ? styles.colors.warning : styles.colors.healthy}} />
        ${card.displayName}
      </div>
      <div style={styles.row}>
        <div style={{...styles.statBlock, borderLeft: \`3px solid \${styles.colors.healthy}\`}}>
          <span style={{...styles.statValue, color: styles.colors.healthy}}>{healthy}</span>
          <span style={styles.statLabel}>Healthy</span>
        </div>
        <div style={{...styles.statBlock, borderLeft: \`3px solid \${styles.colors.error}\`}}>
          <span style={{...styles.statValue, color: unhealthy > 0 ? styles.colors.error : styles.colors.info}}>{unhealthy}</span>
          <span style={styles.statLabel}>Unhealthy</span>
        </div>
      </div>
    </div>
  );
};`

    case 'pod_issues':
      return `
export const render = ({ state }) => {
  if (state.loading) {
    return <div style={styles.card}><span style={{color: styles.colors.info}}>Loading...</span></div>;
  }
  if (state.error) {
    return <div style={styles.card}><span style={{color: styles.colors.error}}>Error: {state.error}</span></div>;
  }

  const issues = state.data?.issues || state.data || [];
  const crashLoop = issues.filter(i => i.reason === 'CrashLoopBackOff').length;
  const oomKilled = issues.filter(i => i.reason === 'OOMKilled').length;
  const other = issues.length - crashLoop - oomKilled;

  return (
    <div style={styles.card}>
      <div style={styles.cardTitle}>
        <span style={{...styles.statusDot, backgroundColor: issues.length > 0 ? styles.colors.warning : styles.colors.healthy}} />
        ${card.displayName}
      </div>
      <div style={{fontSize: '12px', color: '#9ca3af', marginBottom: '8px'}}>
        {issues.length} total issues
      </div>
      <div style={styles.column}>
        {crashLoop > 0 && (
          <div style={{...styles.row, padding: '4px 8px', backgroundColor: 'rgba(239, 68, 68, 0.1)', borderRadius: '4px'}}>
            <span style={{color: styles.colors.error, fontWeight: 600}}>{crashLoop}</span>
            <span style={{color: '#9ca3af', fontSize: '12px'}}>CrashLoopBackOff</span>
          </div>
        )}
        {oomKilled > 0 && (
          <div style={{...styles.row, padding: '4px 8px', backgroundColor: 'rgba(234, 179, 8, 0.1)', borderRadius: '4px'}}>
            <span style={{color: styles.colors.warning, fontWeight: 600}}>{oomKilled}</span>
            <span style={{color: '#9ca3af', fontSize: '12px'}}>OOMKilled</span>
          </div>
        )}
        {other > 0 && (
          <div style={{...styles.row, padding: '4px 8px', backgroundColor: 'rgba(59, 130, 246, 0.1)', borderRadius: '4px'}}>
            <span style={{color: styles.colors.info, fontWeight: 600}}>{other}</span>
            <span style={{color: '#9ca3af', fontSize: '12px'}}>Other</span>
          </div>
        )}
        {issues.length === 0 && (
          <div style={{color: styles.colors.healthy, fontSize: '14px'}}>No issues detected</div>
        )}
      </div>
    </div>
  );
};`

    case 'gpu_overview':
      return `
export const render = ({ state }) => {
  if (state.loading) {
    return <div style={styles.card}><span style={{color: styles.colors.info}}>Loading...</span></div>;
  }
  if (state.error) {
    return <div style={styles.card}><span style={{color: styles.colors.error}}>Error: {state.error}</span></div>;
  }

  const nodes = state.data?.nodes || state.data || [];
  const totalGPUs = nodes.reduce((sum, n) => sum + (n.gpuCount || 0), 0);
  const allocatedGPUs = nodes.reduce((sum, n) => sum + (n.gpuAllocated || 0), 0);
  const utilization = totalGPUs > 0 ? Math.round((allocatedGPUs / totalGPUs) * 100) : 0;

  return (
    <div style={styles.card}>
      <div style={styles.cardTitle}>
        <span style={{...styles.statusDot, backgroundColor: styles.colors.purple}} />
        ${card.displayName}
      </div>
      <div style={{textAlign: 'center', marginBottom: '12px'}}>
        <div style={{fontSize: '32px', fontWeight: 700, color: styles.colors.purple}}>{utilization}%</div>
        <div style={{fontSize: '12px', color: '#9ca3af'}}>Utilization</div>
      </div>
      <div style={styles.row}>
        <div style={styles.statBlock}>
          <span style={styles.statValue}>{totalGPUs}</span>
          <span style={styles.statLabel}>Total</span>
        </div>
        <div style={styles.statBlock}>
          <span style={{...styles.statValue, color: styles.colors.purple}}>{allocatedGPUs}</span>
          <span style={styles.statLabel}>Allocated</span>
        </div>
      </div>
    </div>
  );
};`

    default:
      return `
export const render = ({ state }) => {
  if (state.loading) {
    return <div style={styles.card}><span style={{color: styles.colors.info}}>Loading...</span></div>;
  }
  if (state.error) {
    return <div style={styles.card}><span style={{color: styles.colors.error}}>Error: {state.error}</span></div>;
  }

  return (
    <div style={styles.card}>
      <div style={styles.cardTitle}>${card?.displayName || cardType}</div>
      <pre style={{fontSize: '10px', overflow: 'auto', maxHeight: '100px'}}>
        {JSON.stringify(state.data, null, 2)}
      </pre>
    </div>
  );
};`
  }
}

// Generate Übersicht widget code for stat blocks
export function generateStatWidget(
  statIds: string[],
  apiEndpoint: string,
  refreshInterval: number = 60000,
  layout: 'row' | 'grid' = 'row'
): string {
  const stats = statIds.map((id) => WIDGET_STATS[id]).filter(Boolean)
  if (stats.length === 0) {
    throw new Error('No valid stat IDs provided')
  }

  const endpoints = [...new Set(stats.map((s) => `${apiEndpoint}${s.apiEndpoint}`))]

  return `/**
 * Stats Widget
 * Displays: ${stats.map((s) => s.displayName).join(', ')}
 *
 * Generated by KubeStellar Console
 */

const config = {
  apiEndpoint: '${apiEndpoint}',
  refreshInterval: ${refreshInterval},
};

export const command = async (dispatch) => {
  try {
    const results = await Promise.all([
      ${endpoints.map((ep) => `fetch('${ep}').then(r => r.json())`).join(',\n      ')}
    ]);
    dispatch({ type: 'DATA_LOADED', data: results });
  } catch (error) {
    dispatch({ type: 'ERROR', error: error.message });
  }
};

export const refreshFrequency = config.refreshInterval;

export const initialState = {
  loading: true,
  error: null,
  data: null,
};

export const updateState = (event, previousState) => {
  switch (event.type) {
    case 'DATA_LOADED':
      return { ...previousState, loading: false, error: null, data: event.data };
    case 'ERROR':
      return { ...previousState, loading: false, error: event.error };
    default:
      return previousState;
  }
};

${generateWidgetStyles()}

const StatBlock = ({ value, label, color }) => (
  <div style={{...styles.statBlock, borderTop: \`3px solid \${color}\`}}>
    <span style={{...styles.statValue, color}}>{value}</span>
    <span style={styles.statLabel}>{label}</span>
  </div>
);

export const render = ({ state }) => {
  if (state.loading) {
    return <div style={styles.row}><span style={{color: styles.colors.info}}>Loading...</span></div>;
  }
  if (state.error) {
    return <div style={styles.row}><span style={{color: styles.colors.error}}>Error</span></div>;
  }

  // Extract values from API responses
  const getData = (path, data) => {
    try {
      return eval(\`data.\${path}\`) || 0;
    } catch {
      return 0;
    }
  };

  const allData = state.data || [];

  return (
    <div style={{...styles.${layout}, ${layout === 'grid' ? "gridTemplateColumns: 'repeat(2, 1fr)'" : ''}}}>
      ${stats
        .map((stat) => {
          const dataIndex = endpoints.indexOf(`${apiEndpoint}${stat.apiEndpoint}`)
          return `<StatBlock
        value={getData('${stat.dataPath}', allData[${dataIndex}])}
        label="${stat.displayName}"
        color="${stat.color}"
      />`
        })
        .join('\n      ')}
    </div>
  );
};
`
}

// Generate Übersicht widget code for a template
export function generateTemplateWidget(
  templateId: string,
  apiEndpoint: string,
  refreshInterval: number = 30000
): string {
  const template = WIDGET_TEMPLATES[templateId]
  if (!template) {
    throw new Error(`Unknown template: ${templateId}`)
  }

  const allEndpoints: string[] = []

  // Collect endpoints from cards
  template.cards.forEach((cardType) => {
    const card = WIDGET_CARDS[cardType]
    if (card) {
      card.apiEndpoints.forEach((ep) => {
        if (!allEndpoints.includes(ep)) {
          allEndpoints.push(ep)
        }
      })
    }
  })

  // Collect endpoints from stats
  template.stats?.forEach((statId) => {
    const stat = WIDGET_STATS[statId]
    if (stat && !allEndpoints.includes(stat.apiEndpoint)) {
      allEndpoints.push(stat.apiEndpoint)
    }
  })

  return `/**
 * ${template.displayName} Widget
 * ${template.description}
 *
 * Includes: ${[...template.cards, ...(template.stats || [])].join(', ')}
 * Generated by KubeStellar Console
 */

const config = {
  apiEndpoint: '${apiEndpoint}',
  refreshInterval: ${refreshInterval},
};

export const command = async (dispatch) => {
  try {
    const [${allEndpoints.map((_, i) => `data${i}`).join(', ')}] = await Promise.all([
      ${allEndpoints.map((ep) => `fetch('${apiEndpoint}${ep}').then(r => r.json())`).join(',\n      ')}
    ]);
    dispatch({
      type: 'DATA_LOADED',
      ${allEndpoints.map((ep, i) => `'${ep.replace('/api/mcp/', '')}': data${i}`).join(',\n      ')}
    });
  } catch (error) {
    dispatch({ type: 'ERROR', error: error.message });
  }
};

export const refreshFrequency = config.refreshInterval;

export const initialState = {
  loading: true,
  error: null,
};

export const updateState = (event, previousState) => {
  if (event.type === 'ERROR') {
    return { ...previousState, loading: false, error: event.error };
  }
  if (event.type === 'DATA_LOADED') {
    const { type, ...data } = event;
    return { ...previousState, loading: false, error: null, ...data };
  }
  return previousState;
};

${generateWidgetStyles()}

// Sub-components for each card/stat
${template.cards.map((cardType) => generateMiniCardComponent(cardType)).join('\n\n')}

${template.stats?.map((statId) => generateMiniStatComponent(statId)).join('\n\n') || ''}

export const render = ({ state }) => {
  if (state.loading) {
    return <div style={styles.card}><span style={{color: styles.colors.info}}>Loading...</span></div>;
  }
  if (state.error) {
    return <div style={styles.card}><span style={{color: styles.colors.error}}>Error: {state.error}</span></div>;
  }

  return (
    <div style={{...styles.card, ...styles.${template.layout}${template.layout === 'grid' ? `, gridTemplateColumns: 'repeat(${template.gridCols || 2}, 1fr)'` : ''}}}>
      ${template.stats && template.stats.length > 0 ? `<div style={styles.row}>\n        ${template.stats.map((statId) => `<${statId.replace(/_/g, '')}Stat state={state} />`).join('\n        ')}\n      </div>` : ''}
      ${template.cards.map((cardType) => `<${cardType.replace(/_/g, '')}Card state={state} />`).join('\n      ')}
    </div>
  );
};
`
}

// Generate mini card component for templates
function generateMiniCardComponent(cardType: string): string {
  const card = WIDGET_CARDS[cardType]
  if (!card) return ''

  const componentName = cardType.replace(/_/g, '') + 'Card'

  switch (cardType) {
    case 'cluster_health':
      return `const ${componentName} = ({ state }) => {
  const clusters = state.clusters || [];
  const healthy = clusters.filter(c => c.healthy !== false).length;
  return (
    <div style={{...styles.statBlock, flex: 1}}>
      <span style={{...styles.statValue, color: styles.colors.healthy}}>{healthy}/{clusters.length}</span>
      <span style={styles.statLabel}>Clusters</span>
    </div>
  );
};`

    case 'pod_issues':
      return `const ${componentName} = ({ state }) => {
  const issues = state['pod-issues'] || [];
  return (
    <div style={{...styles.statBlock, flex: 1, borderLeft: issues.length > 0 ? '3px solid ' + styles.colors.warning : '3px solid ' + styles.colors.healthy}}>
      <span style={{...styles.statValue, color: issues.length > 0 ? styles.colors.warning : styles.colors.healthy}}>{issues.length}</span>
      <span style={styles.statLabel}>Pod Issues</span>
    </div>
  );
};`

    case 'gpu_overview':
      return `const ${componentName} = ({ state }) => {
  const nodes = state['gpu-nodes'] || [];
  const total = nodes.reduce((s, n) => s + (n.gpuCount || 0), 0);
  return (
    <div style={{...styles.statBlock, flex: 1}}>
      <span style={{...styles.statValue, color: styles.colors.purple}}>{total}</span>
      <span style={styles.statLabel}>GPUs</span>
    </div>
  );
};`

    default:
      return `const ${componentName} = ({ state }) => (
  <div style={{...styles.statBlock, flex: 1}}>
    <span style={styles.statLabel}>${card.displayName}</span>
  </div>
);`
  }
}

// Generate mini stat component for templates
function generateMiniStatComponent(statId: string): string {
  const stat = WIDGET_STATS[statId]
  if (!stat) return ''

  const componentName = statId.replace(/_/g, '') + 'Stat'

  return `const ${componentName} = ({ state }) => {
  const value = (() => {
    try {
      const data = state;
      return ${stat.dataPath.includes('reduce') || stat.dataPath.includes('filter') ? `(data.${stat.dataPath.split('.')[0]} || []).${stat.dataPath.split('.').slice(1).join('.')}` : `data.${stat.dataPath}`} || 0;
    } catch { return 0; }
  })();
  return (
    <div style={{...styles.statBlock, borderTop: '2px solid ${stat.color}'}}>
      <span style={{...styles.statValue, fontSize: '18px', color: '${stat.color}'}}>{value}${stat.format === 'percentage' ? '%' : ''}</span>
      <span style={{...styles.statLabel, fontSize: '9px'}}>${stat.displayName}</span>
    </div>
  );
};`
}

// Main generator function
export function generateWidget(config: WidgetConfig): string {
  switch (config.type) {
    case 'card':
      if (!config.cardType) throw new Error('cardType required for card widget')
      return generateCardWidget(config.cardType, config.apiEndpoint, config.refreshInterval)

    case 'stat':
      if (!config.statIds || config.statIds.length === 0) throw new Error('statIds required for stat widget')
      return generateStatWidget(config.statIds, config.apiEndpoint, config.refreshInterval)

    case 'template':
      if (!config.templateId) throw new Error('templateId required for template widget')
      return generateTemplateWidget(config.templateId, config.apiEndpoint, config.refreshInterval)

    default:
      throw new Error(`Unknown widget type: ${config.type}`)
  }
}

// Get filename for widget
export function getWidgetFilename(config: WidgetConfig): string {
  switch (config.type) {
    case 'card':
      return `${config.cardType?.replace(/_/g, '-')}.widget.jsx`
    case 'stat':
      return `stats-${config.statIds?.join('-')}.widget.jsx`
    case 'template':
      return `${config.templateId?.replace(/_/g, '-')}.widget.jsx`
    default:
      return 'widget.jsx'
  }
}
